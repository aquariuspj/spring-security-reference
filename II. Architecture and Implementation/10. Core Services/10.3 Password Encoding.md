### 10.3 密码编码

Spring Security的`PasswordEncoder`用来支持密码编码。你不应该使用明文方式保存密码。坚持使用一种密码哈希算法，例如bcrypt，此算法使用了一种加盐的方式，因此对于每个存储的密码都是不一样的。不要使用像是MD5或SHA（包括加盐版本）这样的简单哈希方法。Bcrypt有意设计得更慢，从而阻止离线密码破解，不像标准哈希算法那样快并且能够通过并行的硬件很快的测试成百上千个密码。你也许想，这不会发生在你身上，因为你的密码在数据库上是安全的，离线密码攻击并不是一个风险。如果是这样，那么你应该做一些研究，并且了解所有的使用了这种方式并被警示为不安全的知名网站。你的站点最好更安全一些。使用"org.springframework.security.crypto.bcrypt.BCryptPasswordEncoder"是一个不错的安全选择。还有一些由另外的通用的程序语言实现的兼容的组件，你也可以试试。

如果你正在使用一个已经使用了哈希密码的遗留系统，那么你需要使用适合你当前算法的编码器，至少持续到你能够迁移你的用户到更安全的schema（通常这会牵扯到让你的用户设置一个新的密码，因为哈希是不可逆的）。Spring Security具有一个包含了遗留密码的编码实现，即`org.springframework.security.authentication.encoding`。`DaoAuthenticationProvider`可以以新的或遗留的`PasswordEncoder`类型被注入。

#### 10.3.1 什么是哈希

密码哈希并不是Spring Security所特有的，它是一种非常通用混淆工具。一种哈希（或摘要）算法是一种单向的函数，它用来从像是密码这样的输入数据中生成一些另外的固定长度的数据。例如，使用MD5对字符串"password"（16进制）进行哈希得到如下结果：

	5f4dcc3b5aa765d61d8327deb882cf99

哈希是单向的，想要获取给定哈希值的源输入非常困难（实际上是不可能的），任何输入都可能产生这个哈希值。这种性质使得哈希值在认证中非常有用。它可以被存储在你的用户数据库中来替代明文密码存储，即使密码暴露，盗用者也不能立即使用此密码进行登陆。这意味一旦密码被编码，那么你无法还原它。

#### 10.3.2 加盐的哈希

密码哈希存在一种潜在的问题，使用同样的单词进行单向的运算非常简单。人们常常会使用相似的密码，以前被黑的站点中存在着大量的这样的字典，它们都是可用的。如果你用google查找哈希值 `5f4dcc3b5aa765d61d8327deb882cf99`，你可以很快找到源单词"password"。用类似的方法，一个攻击者可以用标准的单词清单构建一个哈希字典，从而用来寻找源密码。预防这种攻击的方式是使用健壮的密码策略，意思是说不要用一些已存在的单词组合。另一种方式是使用加盐的哈希算法。在对每个用户的密码进行计算之前，都加上附加的字符串，附加的字符串叫做盐。理想的盐是尽可能随机的，但实际上任何盐值都是可取的。一旦加了盐，意味着攻击者必须根据每一个盐值来构建单独的字典，攻击者需要做更多的工作（但并非不可能破解）。

Bcrypt为每个加密的密码都自动生成一个随机的盐值，并且用一种标准的格式在bcrypt字符串中存储它。

> 操作盐的遗留的方法就是给`DaoAuthenticationProvider`注入一个`SaltSource`，它会为特定的用户获取一个盐值，并传递到`PasswordEncoder`当中。使用bcrypt意味着你不需要考虑盐值操作的详情（例如该值存储在哪里），它们都会在算法内部被完成。因此我们非常推荐你使用bcrypt，除非你已经有一个新系统，来单独的存储盐值。

#### 10.3.3 哈希与认证

当一个认证provider（例如Spring Security的`DaoAuthenticationProvider`）需要为用户检查一个被提交上来的密码时，如果已知的密码值被以某种方式编码，那么提交值也必须被以同样的算法进行编码才能进行比较。Spring Security是否对这些加密值进行控制取决于你。如果你添加密码哈希到你的Spring Security认证配置中，并且你的数据库包含了明文密码，那么肯定会认证失败。就算你对你数据库中的密码进行MD5编码，同时你的应用程序配置了使用Spring Security的`Md5PasswordEncoder`，这样仍可能会有问题。数据库可能使用了Base 64进行编码，例如编码器使用了hexadecimal字符串（默认情况）。或者你的数据库使用了大写存储方式，而编码输出的时候是小写。在你做更多事情并且给你的应用添加认证之前，自己写一个测试，对你配置中的密码编码进行测试，加上些盐，然后将其与数据库中的值进行对比。使用标准的方式，例如bcrypt算法，可以帮你避免这些问题。

如果你希望在Java中直接生成密码，并存储到你的用户数据库中，那么你可以使用`PasswordEncoder`的`encode`方法。


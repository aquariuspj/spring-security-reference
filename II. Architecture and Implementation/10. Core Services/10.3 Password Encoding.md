### 10.3 密码编码

Spring Security的`PasswordEncoder`用来支持密码编码。你不应该使用明文方式保存密码。坚持使用一种密码哈希算法，例如bcrypt，此算法使用了一种加盐的方式，因此对于每个存储的密码都是不一样的。不要使用像是MD5或SHA（包括加盐版本）这样的简单哈希方法。Bcrypt有意设计得更慢，从而阻止离线密码破解，不像标准哈希算法那样快并且能够通过并行的硬件很快的测试成百上千个密码。你也许想，这不会发生在你身上，因为你的密码在数据库上是安全的，离线密码攻击并不是一个风险。如果是这样，那么你应该做一些研究，并且了解所有的使用了这种方式并被警示为不安全的知名网站。你的站点最好更安全一些。使用"org.springframework.security.crypto.bcrypt.BCryptPasswordEncoder"是一个不错的安全选择。还有一些由另外的通用的程序语言实现的兼容的组件，你也可以试试。

如果你正在使用一个已经使用了哈希密码的遗留系统，那么你需要使用适合你当前算法的编码器，至少持续到你能够迁移你的用户到更安全的schema（通常这会牵扯到让你的用户设置一个新的密码，因为哈希是不可逆的）。Spring Security具有一个包含了遗留密码的编码实现，即`org.springframework.security.authentication.encoding`。`DaoAuthenticationProvider`可以以新的或遗留的`PasswordEncoder`类型被注入。

#### 10.3.1 什么是哈希

密码哈希并不是Spring Security所特有的，它是一种非常通用混淆工具。一种哈希（或摘要）算法是一种单向的函数，它用来从像是密码这样的输入数据中生成一些另外的固定长度的数据。例如，使用MD5对字符串"password"（16进制）进行哈希得到如下结果：

	5f4dcc3b5aa765d61d8327deb882cf99

哈希是单向的，想要获取给定哈希值的源输入非常困难（实际上是不可能的），任何输入都可能产生这个哈希值。这种性质使得哈希值在认证中非常有用。它可以被存储在你的用户数据库中来替代明文密码存储，即使密码暴露，盗用者也不能立即使用此密码进行登陆。这意味一旦密码被编码，那么你无法还原它。

#### 10.3.2 加盐的哈希

密码哈希存在一种潜在的问题，使用同样的单词进行单向的运算非常简单。人们常常会使用相似的密码，以前被黑的站点中存在着大量的这样的字典，它们都是可用的。如果你用google查找哈希值 `5f4dcc3b5aa765d61d8327deb882cf99`，你可以很快找到源单词"password"。用类似的方法，一个攻击者可以用标准的单词清单构建一个哈希字典，从而用来寻找源密码。预防这种攻击的方式是使用健壮的密码策略，意思是说不要用一些已存在的单词组合。另一种方式是使用加盐的哈希算法。在对每个用户的密码进行计算之前，都加上附加的字符串，附加的字符串叫做盐。理想的盐是尽可能随机的，但实际上任何盐值都是可取的。一旦加了盐，意味着攻击者必须根据每一个盐值来构建单独的字典，攻击者需要做更多的工作（但并非不可能破解）。

Bcrypt为每个加密的密码都自动生成一个随机的盐值，并且用一种标准的格式在bcrypt字符串中存储它。

> 操作盐的遗留的方法就是给`DaoAuthenticationProvider`注入一个`SaltSource`，它会为特定的用户获取一个盐值，并传递到`PasswordEncoder`当中。使用bcrypt意味着你不需要考虑盐值操作的详情（例如该值存储在哪里），它们都会在算法内部被完成。因此我们非常推荐你使用bcrypt，除非你已经有一个新系统，来单独的存储盐值。

#### 10.3.3 哈希与认证

当一个认证provider（例如Spring Security的`DaoAuthenticationProvider`）需要检查密码时，

When an authentication provider (such as Spring Security’s DaoAuthenticationProvider) needs to check the password in a submitted authentication request against the known value for a user, and the stored password is encoded in some way, then the submitted value must be encoded using exactly the same algorithm. It’s up to you to check that these are compatible as Spring Security has no control over the persistent values. If you add password hashing to your authentication configuration in Spring Security, and your database contains plaintext passwords, then there is no way authentication can succeed. Even if you are aware that your database is using MD5 to encode the passwords, for example, and your application is configured to use Spring Security’s Md5PasswordEncoder, there are still things that can go wrong. The database may have the passwords encoded in Base 64, for example while the encoder is using hexadecimal strings (the default). Alternatively your database may be using upper-case while the output from the encoder is lower-case. Make sure you write a test to check the output from your configured password encoder with a known password and salt combination and check that it matches the database value before going further and attempting to authenticate through your application. Using a standard like bcrypt will avoid these issues.

If you want to generate encoded passwords directly in Java for storage in your user database, then you can use the encode method on the PasswordEncoder.